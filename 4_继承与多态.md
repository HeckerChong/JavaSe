# 第一章 继承

**概述**

多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。

- ![生活中的继承](./images/生活中的继承.png)

其中，多个类可以称为**子类**，单独那一个类称为**父类**、**超类（superclass）** 或者 **基类**。

继承描述的是事物之间的所属关系，这种关系是：`is-a`的关系。例如，图中兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。

## 1.1 定义

* **继承**：就是子类继承父类的**属性**和**行为**，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的**非私有**的属性和行为。

**优点**

* 提高**代码的复用性**。
* 类与类之间产生了关系，是**多态的前提**。

## 1.2 继承的格式

通过`extends`关键字，可以声明一个子类继承另外一个父类

```java
class 父类 {
    ...
}

class 子类 extends 父类 {
    ...
}
```

**示例：**

```java
/**
    * 定义员工类Employee，做为父类
    */
class Employee {

    // 定义name属性
    String name;
    // 定义员工的工作方法
    public void work() {
        System.out.println("尽心尽力地工作");
    }

}

/**
    * 定义讲师类Teacher 继承员工类Employee
    */
class Teacher extends Employee {

    // 定义一个打印name的方法
    public void printName() {
        System.out.println("name=" + name);
    }
}

/**
    * 定义测试类
    */
public class ExtendDemo01 {

    public static void main(String[] args) {

        // 创建一个讲师类对象
        Teacher t = new Teacher();

        // 为该员工类的name属性进行赋值
        t.name = "小明";

        // 调用该员工的printName()方法
        t.printName(); // name = 小明

        // 调用Teacher类继承来的work()方法
        t.work(); // 尽心尽力地工作
    }
}
```

## 1.3 继承后的特点——成员变量

子类父类中出现**不重名**的成员变量，这时的访问是**没有影响**的。
子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用`super`关键字，修饰父类成员变量。

**格式**

```java
super.父类成员变量名
```

```java
class Fu {
    // Fu中的成员变量。
    int num = 5;
}

class Zi extends Fu {

    // Zi中的成员变量
    int num = 6;

    public void show() {

        // 访问父类中的num
        System.out.println("Fu num=" + super.num);
        // 访问子类中的num
        System.out.println("Zi num=" + this.num);
    }

}

public class ExtendsDemo {
    public static void main(String[] args) {

        Zi zi = new Zi();

        // 子类中有show方法，只执行重写后的show方法
        zi.show();
    }
}

/**
 * 输出结果：
 * Fu num=5
 * Zi num=6
 */
```

> Tips:
> Fu类中的成员变量是非私有的，子类中可以直接访问。若Fu类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量。可以在父类中提供公共的getXxx方法和setXxx方法，访问父类的私有成员变量。

## 1.4 继承后的特点——成员方法

子类父类中出现**不重名**的成员方法，这时的调用是**没有影响**。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。

**成员方法重名——重写(Override)**

子类父类中出现**重名**的成员方法，这时的访问是一种特殊情况，叫做**方法重写 (Override)**。

* **方法重写** ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。**声明不变，重新实现**。

```java
class Fu {

    public void show() {
        System.out.println("Fu show");
    }

}

class Zi extends Fu {

    //子类重写了父类的show方法
    public void show() {
        System.out.println("Zi show");
    }

}

public class ExtendsDemo {
    public static void main(String[] args) {

        Zi zi = new Zi();

        // 子类中有show方法，只执行重写后的show方法
        zi.show();
    }
}

/**
 * 输出结果：
 * Zi show
 */
```

> Tips：
> 子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。

**注意事项**
1. 子类方法覆盖父类方法，必须要保证权限大于等于父类权限。
2. 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。

## 1.5 继承后的特点——构造方法

1. 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。
2. 构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构 造方法中默认有一个`super()`，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。

```java
class Fu {

    private int n;

    public Fu() {
        System.out.println("Fu()");
    }
}

class Zi extends Fu {

    public Zi() {

        super();
        System.out.println("Zi()");
    }

}

public class ExtendsDemo{

    public static void main(String[] args) {
        Zi zi = new Zi();
    }

}

/**
 * 输出结果：
 * Fu()
 * Zi()
 */
```

## 1.6 super和this

**父类空间优先于子类对象产生**

在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。

- ![父类空间优先于子类对象产生](./images/父类空间优先于子类对象产生.png)

**super和this的含义**

* **super**：代表父类的**存储空间标识**(可以理解为父类的引用)。
* **this**：代表当前**对象的引用**(谁调用就代表谁)。

**super和this的用法**

1. 访问成员

```java
this.成员变量   -- 本类的
super.成员变量  -- 父类的

this.成员方法名()   -- 本类的
super.成员方法名()  -- 父类的
```

2. 访问构造方法

```java
this(...);  -- 本类的构造方法
super(...); -- 父类的构造方法
```

> Tips:
> 子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。
> super()和this()都必须是在构造方法的第一行，所以不能同时出现。

## 1.7 继承的特点

1. Java只支持单继承，不支持多继承。
2. Java支持多层继承(继承体系)。
3. 子类和父类是一种相对的概念。

```java
//一个类只能有一个父类，不可以有多个父类。 
class C extends A{} //ok 
class C extends A,B... //error

class A{} 
class B extends A{} 
class C extends B{}
```

> 顶层父类是Object类。所有的类默认继承Object，作为父类。

# 第二章 抽象类

**概述**

父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为**抽象方法**。Java语法规定，包含抽象方法的类就是**抽象类**。

## 2.1 定义

* **抽象方法**： 没有方法体的方法。
* **抽象类**：包含抽象方法的类。

## 2.2 abstract使用格式

### 2.2.1 抽象方法

使用`abstract`关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。

**格式**

```java
修饰符 abstract 返回值类型 方法名 (参数列表);
```

**示例**

```java
public abstract void run();
```

### 2.2.2 抽象类

如果一个类包含抽象方法，那么该类必须是抽象类。

**格式**

```java
abstract class 类名字 {

}
```

**示例**

```java
public abstract class Animal { 
    public abstract void run();
}
```

### 2.2.3 抽象的使用

继承抽象类的子类**必须重写父类所有的抽象方法**。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。

```java
public abstract class Animal {
    public abstract void run();
}

public class Cat extends Animal {

    public void run() {
        System.out.println("猫在跑");
    }
}

public class CatTest {

    public static void main(String[] args) {
        //创建子类对象
        Cat cat = new Cat();
        //调用run方法
        cat.run();
    }
}

//输出结果：猫在跑
```

> 此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做**实现方法**。

## 2.3 注意事项

1. 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。
> 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。
2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。
> 理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。
3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
> 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。
4. 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。
> 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。






















