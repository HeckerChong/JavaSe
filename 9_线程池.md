# 第一章 等待唤醒机制

## 1.1 线程间通信

**概念**：多个线程在处理同一个资源，但是处理的动作(线程的任务)却不相同。

比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。

- ![线程间通信](./images/线程间通信.bmp)

**为什么要处理线程间通信：**

多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。

**如何保证线程间通信有效利用资源：**

多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即——**等待唤醒机制**。

## 1.2 等待唤醒机制

**什么是等待唤醒机制？**

这是多个线程间的一种**协作**机制。谈到线程我们经常想到的是线程间的**竞争(race)**，比如去争夺锁，但这并不是全部，线程间也会有协作机制。

就是在一个线程进行了规定操作后，就进入等待状态(**wait()**)， 等待其他线程执行完他们的指定代码过后 再将其唤醒(**notify()**);在有多个线程进行等待时， 如果需要，可以使用**notifyAll()**来唤醒所有的等待线程。

wait/notify 就是线程间的一种协作机制。

**等待唤醒中的方法**

1. wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是WAITING。它还要等着别的线程执行一个**特别**的动作，也即是“**通知(notify)**”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列(ready queue)中。
2. notify：则选取所通知对象的wait set中的一个线程释放;例如，餐馆有空位置后，等候就餐最久的顾客最先入座。
3. notifyAll：则释放所通知对象的wait set上的全部线程。

> Tips:
> 哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁(很可能面临其它线程的竞争)，成功后才能在当初调用wait方法之后的地方恢复执行。

* 如果能获取锁，线程就从**WAITING**状态变成**RUNNABLE**状态;
* 否则，从**wait set**出来，又进入**entry set**，线程就从 **WAITING** 状态又变成**BLOCKED**状态

**调用wait和notify方法需要注意的细节：**

1. wait方法与notify方法必须要由同一个锁对象调用。因为:对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。
2. wait方法与notify方法是属于Object类的方法。因为:锁对象可以是任意对象，而任意对象的所属类都是继承了Object类。
3. wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为必须要通过锁对象调用这2个方法。

## 1.3 生产者与消费者问题

等待唤醒机制其实就是经典的“生产者与消费者”的问题。

就拿生产包子消费包子来说等待唤醒机制如何有效利用资源:

> 包子铺线程生产包子，吃货线程消费包子。当包子没有时(包子状态为false)，吃货线程等待，包子铺线程生产包子 (即包子状态为true)，并通知吃货线程(解除吃货的等待状态),因为已经有包子了，那么包子铺线程进入等待状态。 接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完(包 子状态为false)，并通知包子铺线程(解除包子铺的等待状态),吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。

**示例：**

```java
//包子资源类
public class BaoZi {

    private String Pi;
    private String Xian;
    //包子资源，是否存在，包子资源状态
    private boolean flag=false;

    public String getPi() {
        return Pi;
    }

    public void setPi(String pi) {
        Pi = pi;
    }

    public String getXian() {
        return Xian;
    }

    public void setXian(String xian) {
        Xian = xian;
    }

    public boolean isFlag() {
        return flag;
    }

    public void setFlag(boolean flag) {
        this.flag = flag;
    }
}
```

```java
//吃货线程类
public class ChiHuo extends Thread {

    private BaoZi bz;

    public ChiHuo(BaoZi bz) {
        this.bz = bz;
    }

    @Override
    public void run() {

        bz.setPi("薄皮");
        bz.setXian("白菜猪肉馅");

        while (true) {

            synchronized (bz) {

                //没包子
                if (bz.isFlag() == false) {
                    try {
                        bz.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                System.out.println("包子真好吃--------->");
                System.out.println("吃完了。。。。。");

                bz.setFlag(false);
                //唤醒等待线程（BaoZiPu）
                bz.notify();

            }
        }
    }
}
```

```java
//包子铺线程类
public class BaoZiPu extends Thread {

    private BaoZi bz;

    public BaoZiPu(BaoZi bz) {
        this.bz = bz;
    }

    @Override
    public void run() {

        bz.setPi("薄皮");
        bz.setXian("白菜猪肉馅");

        while (true) {

            synchronized (bz) {

                //有包子
                if (bz.isFlag() == true) {

                    try {
                        bz.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                System.out.println("正在制作--------->");

                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println("制作好了：" + bz.getPi() + bz.getXian());

                bz.setFlag(true);
                //唤醒等待线程（ChiHuo）
                bz.notify();
            }
        }
    }
}
```

```java
//测试类
public class ThreadTest {

    public static void main(String[] args) {

        BaoZi baoZi = new BaoZi();

        new BaoZiPu(baoZi).start();
        new ChiHuo(baoZi).start();

    }
}
```

# 第二章 线程池

## 2.1 线程池概念

* **线程池**：就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。

- ![线程池原理](./images/线程池原理.bmp)

**合理利用线程池的优点：**

1. 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
2. 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
3. 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。

## 2.3 线程池的使用

Java里面线程池的顶级接口是`java.util.concurrent.Executor`，但是严格意义上讲`Executor`并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是`java.util.concurrent.ExecutorService`。

`java.util.concurrent.Executors`线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。

**Executors类中创建线程池的方法：**

* `public static ExecutorService newFixedThreadPool(int nThreads)`：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)。

获取到了一个线程池ExecutorService对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法：

* `public Future<?> submit(Runnable task)`：获取线程池中的某一个线程对象，并执行。

> Future接口:用来记录线程任务执行完毕后产生的结果。线程池创建与使用。

使用线程池中线程对象的步骤：

1. 创建线程池对象。
2. 创建Runnable接口子类对象。(task)
3. 提交Runnable接口子类对象。(take task)
4. 关闭线程池(一般不做)。

```java
//Runnable实现类
public class MyRunnable implements Runnable{

    @Override
    public void run() {

        System.out.println("开始装逼=======》");

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("装逼结束");
    }
}
```

```java
//线程池测试类
public class ThreadPoolDemo01 {

    public static void main(String[] args) {

        //创建线程池对象
        ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象

        service.submit(new MyRunnable());
        service.submit(new MyRunnable());
        //submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。

        //关闭线程池
        service.shutdown();
    }

}
```












